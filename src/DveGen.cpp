//------------------------------------------------------------------------------
//--  Copyright (c) 2004,2005,2006 by Eric Fahlgren                           --
//--  All Rights Reserved.                                                    --
//--                                                                          --
//--  This program is free software; you can redistribute it and/or           --
//--  modify it under the terms of the GNU General Public License             --
//--  as published by the Free Software Foundation; either version            --
//--  2 of the License, or (at your option) any later version.                --
//--  See http://www.gnu.org/licenses/gpl.txt                                 --
//------------------------------------------------------------------------------

#include "stdafx.h"
#include "megatune.h"
#include "DveGen.h"
#include "repository.h"
#include "msDatabase.h"
#include "vegen.h"
#include "tuning3D.h"

#ifdef _DEBUG
#define new DEBUG_NEW
#undef THIS_FILE
static char THIS_FILE[] = __FILE__;
#endif

extern msDatabase mdb;
extern tuningDialog ut[tuningDialog::nUT];

//------------------------------------------------------------------------------

DveGen::DveGen(int nId, CWnd *pParent)
 : dataDialog(DveGen::IDD, pParent)
 , nId(nId)
{
   //{{AFX_DATA_INIT(DveGen)
   //}}AFX_DATA_INIT
}

//------------------------------------------------------------------------------

void DveGen::DoDataExchange(CDataExchange* pDX)
{
   CDialog::DoDataExchange(pDX);
   //{{AFX_DATA_MAP(DveGen)
      DDX_Control(pDX, IDC_DISP_UNITS_CID, m_dispCID);
      DDX_Control(pDX, IDC_VEG_DISP,       m_disp);
      DDX_Control(pDX, IDC_VEG_IDLERPM,    m_idleRPM);
      DDX_Control(pDX, IDC_VEG_IDLEMAP,    m_idleMAP);
      DDX_Control(pDX, IDC_VEG_PTQ,        m_ptq);
      DDX_Control(pDX, IDC_VEG_PTQRPM,     m_ptqRPM);
      DDX_Control(pDX, IDC_VEG_PTQMAP,     m_ptqMAP);
      DDX_Control(pDX, IDC_VEG_PHP,        m_php);
      DDX_Control(pDX, IDC_VEG_PHPRPM,     m_phpRPM);
      DDX_Control(pDX, IDC_VEG_PHPMAP,     m_phpMAP);
      DDX_Control(pDX, IDC_VEG_REDRPM,     m_redRPM);
      DDX_Control(pDX, IDC_VEG_REDMAP,     m_redMAP);
   //}}AFX_DATA_MAP
}

//------------------------------------------------------------------------------

BEGIN_MESSAGE_MAP(DveGen, CDialog)
   //{{AFX_MSG_MAP(DveGen)
      ON_WM_CTLCOLOR()
   //}}AFX_MSG_MAP
END_MESSAGE_MAP()

//------------------------------------------------------------------------------

static double HP = 0.0;
static double TQ = 0.0;

void DveGen::OnOK() 
{
   double dispUnits = m_dispCID.GetCheck() ? 1.0 : 16.38706;

   double disp = getRaw(&m_disp,      30.0*dispUnits,   500.0*dispUnits, "Engine displacement") / dispUnits;
   double xir  = getRaw(&m_idleRPM,  300.0,  1200.0, "Idle RPM");
   double xim  = getRaw(&m_idleMAP,   20.0,    60.0, "Idle MAP");
          TQ   = getRaw(&m_ptq,        0.0,  1000.0, "Peak torque");
   double xqr  = getRaw(&m_ptqRPM,  1000.0, 12000.0, "RPM at torque peak");
   double xqm  = getRaw(&m_ptqMAP,    90.0,   400.0, "MAP at torque peak");
          HP   = getRaw(&m_php,        0.0,  1000.0, "Peak HP");
   double xhr  = getRaw(&m_phpRPM,  1000.0, 12000.0, "RPM at HP peak");
   double xhm  = getRaw(&m_phpMAP,    90.0,   400.0, "MAP at HP peak");
   double xrr  = getRaw(&m_redRPM,  1000.0, 12000.0, "Redline RPM");
   double xrm  = getRaw(&m_redMAP,    90.0,   400.0, "Redline MAP");

   tuningDialog *td = ut+nId;
   const int nRPM = td->x->nValues();
   const int nLOD = td->y->nValues();
   veGen veg(nRPM, nLOD, int(xir), int(xrr), int(xim), int(xrm));
   
   veg.setComment("Generated by MegaTune " VERSION_STRING);

   veg.setPeakTorque  (TQ, int(xqr), int(xqm));
   veg.setPeakHP      (HP, int(xhr), int(xhm));
   veg.setDisplacement(disp);

   if (!veg.checkInputs()) {
      veg.generate();
      // if (writeIt) veg.dump();

      int R;
      for (R = 0; R < nRPM; R++) {
//       mdb.putConstByte(Drpmrangeve+R, veg.rpm(R), true);
         td->x->storeValue(veg.rpm(R)*100, R); // * 100 ???
      }
      mdb.cDesc.send(td->x);
      for (int M = 0; M < nLOD; M++) {
//       int l = veg.load(M);
//       if (mdb.alphaN()) l = mdb.tpsFromPct(BYTE(l));
//       mdb.putConstByte(Dkparangeve+M, l,          true);
         td->y->storeValue(veg.load(M), M);
      }
      mdb.cDesc.send(td->y);

      for (R = 0; R < nRPM; R++) {
         for (int M = 0; M < nLOD; M++) {
            td->z->storeValue(veg.ve(R, M), td->z->index(R, M));
         }
      }
      mdb.cDesc.send(td->z);
   }

   CDialog::OnOK();
}

//------------------------------------------------------------------------------

BOOL DveGen::OnInitDialog() 
{
   dataDialog::OnInitDialog("VE Table Estimator");
   m_dispCID.SetCheck(true);
   setFld(&m_disp,     350, 1.0);
   setFld(&m_idleRPM,  800);
   setFld(&m_idleMAP,   20);
   setFld(&m_ptq,       TQ);
   setFld(&m_ptqRPM,  3000);
   setFld(&m_ptqMAP,   100);
   setFld(&m_php,       HP);
   setFld(&m_phpRPM,  5000);
   setFld(&m_phpMAP,   100);
   setFld(&m_redRPM,  7000);
   setFld(&m_redMAP,   100);
   return TRUE;
}

//------------------------------------------------------------------------------

HBRUSH DveGen::OnCtlColor(CDC* pDC, CWnd* pWnd, UINT nCtlColor) 
{
   HBRUSH hbr = dataDialog::OnCtlColor(pDC, pWnd, nCtlColor);
   if (pWnd->GetDlgCtrlID() == IDC_VEG_WARNING) {
      pDC->SetTextColor(RGB(255,255,255));
      pDC->SetBkMode(TRANSPARENT);
      static CBrush brush;
      brush.DeleteObject();
      brush.CreateSolidBrush(RGB(255,0,0));
      hbr = brush;
   }
   return hbr;
}

//------------------------------------------------------------------------------
